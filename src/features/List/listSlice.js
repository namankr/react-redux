import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import  fetchUser  from "./listApi";

const initialState = {
  user: [],
  status: "idle",
};

export const getUserAsync = createAsyncThunk(
  "user/fetchUser",
  async () => {
    const response = await fetchUser();
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);


export const listSlice = createSlice({
    name: 'user',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
      add: (state) => {
        // Redux Toolkit allows us to write "mutating" logic in reducers. It
        // doesn't actually mutate the state because it uses the Immer library,
        // which detects changes to a "draft state" and produces a brand new
        // immutable state based off those changes
       // state.user = state.user.user.shift() ;
      },
      remove: (state) => {
       // state.value -= 1;
        state.user += state.user.user.shift() 
      },

      // Use the PayloadAction type to declare the contents of `action.payload`
      loadUser: (state, action) => {
        state.user += action.payload;
      },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
      builder
        .addCase(getUserAsync.pending, (state) => {
          state.status = 'loading';
        })
        .addCase(getUserAsync.fulfilled, (state, action) => {
          state.status = 'idle';
          state.user = action.payload;
        });
    },
  });

export const selectUser = (state) => state.user;
export const { add, remove, loadUser } = listSlice.actions;
export default listSlice.reducer;